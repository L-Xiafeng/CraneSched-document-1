{"./":{"url":"./","title":"1 CraneSched简介","keywords":"","body":"CraneSched 简介 鹤思(CraneSched)是北京大学计算中心和北京大学长沙计算与数字经济研究院联合研发的算力中心智能调度系统。通过对高性能计算和智能计算两类作业场景进行细化建模与针对性优化，实现高性能计算与智能计算场景下的资源管理、作业管理、资源隔离、通讯加密等功能。 CraneSched分为前端和后端，前端主要是用Go开发，后端主要是用C++开发，欢迎开发者一起加入。 CraneSched前端开源地址：CraneSched -FrontEnd CraneSched 后端开源地址：CraneSched CraneSched 文档地址：CraneSched-Document CraneSched 在线试用地址（试用账号：demo_admin，密码：demo_admin）：CraneSched -Demo CraneSched 设计理念 完全开源：源代码完全开放可得； 功能强大：支持高性能计算与智能计算两种作业模式； 调度高效：支持每秒调度10000个作业以上，支持同时运行100万个作业以上； 高度可伸缩：支持50000个节点以上的算力中心规模； 安全可靠：RBAC权限控制和通信加密； 代码精炼：代码精炼高效，可读性高； 简洁易用：用户使用指令和系统管理指令简洁易用； 高度可容错：作业故障自动恢复、无单点故障、系统状态快速故障恢复。 CraneSched 架构 针对算力中心的调度场景，CraneSched采用中心化管理模式，Cranectld是部署在主控节点的守护进程，也是调度系统的“大脑”。Craned是部署在计算节点上的守护进程，也是调度系统下达给计算节点的指令的执行者。 Cranectld负责算力中心节点生命周期的管理、作业队列的调度及管理、节点资源调度及管理，处理来自用户指令的作业提交、修改、查询等请求。Craned主要用来监控节点资源及作业状态，接受用户的各种指令，并将其发送给Cranectld，向用户传送Cranectld对指令处理的返回结果。 面向算力网络的国家战略，鹤思智能调度系统计划采用两级调度架构，上层调度为XCraneSched，下层调度为CraneSched，两者结合至上而下解决算力网络中算力资源调度问题。CraneSched针对单个算力中心资源调度，主要运行高性能计算和智能计算作业，通过适配器与XCraneSched连接，并承接来自XCraneSched分派的作业。XCraneSched通过各种适配器去连接超算、智算、云计算等各类算力中心，将其汇聚成一张算力网络，接受用户提交的作业，并将作业分发到最“合适”的算力中心。 "},"features.html":{"url":"features.html","title":"2 CraneSched功能和特点","keywords":"","body":"CraneSched功能和特点 资源管理功能 资源查看 资源调度 资源管理（增加/减少/节点状态变化等） 资源审计（节点状态变化事件记录） 作业管理功能 作业提交 作业取消 作业修改，时间延长等 作业状态查询 作业审计 特点 完全开源 支持高性能计算与智能计算两种作业模式 高可靠故障恢复，容错性高 资源和节点状态可持续化，宕机之后重启自动恢复 高度可扩展性，可以同时支持提交/取消/管理多个独立作业 高性能，每秒可处理多个作业，为作业分配资源并运行 常用命令 cinfo： 查看节点与分区状态 cbatch： 提交批量处理作业 crun： 提交交互式任务 calloc： 提交交互式任务 cqueue： 查看作业队列 ccancel： 取消运行或提交的作业 ccontrol： 查看/修改分区和节点状态 cacctmgr： 查看和调整用户/账号信息 cacct： 查看作业信息 常用术语 job： 作业 node： 计算节点 core： CPU核 tasks： 任务数，一般一个任务使用一个CPU核，可理解为作业所需的CPU核数 partition： 分区 user： 用户名 account： 账户 stdout： 标准输出文件，程序运行正常时输出信息的文件，一般指输出到屏幕的信息 stderr： 标准错误文件，程序运行错误时输出信息的文件，一般指输出到屏幕的信息 "},"config/":{"url":"config/","title":"3 CraneSched安装配置","keywords":"","body":"CraneSched安装教程 CraneSched分为前端和后端，前端主要是用Go语言开发，后端主要用C++语言开发，部署CraneSched项目需要分为前端和后端两部分分别部署构建。 CraneSched后端环境配置 CraneSched前端环境配置 "},"config/CraneConfiguration.html":{"url":"config/CraneConfiguration.html","title":"3.1 CraneSched 后端环境配置","keywords":"","body":"CraneSched 项目环境配置 以下内容为配置代码编译环境，在编译项目的节点执行 环境准备： 关闭seLinux 安装节点：crane01, crane02, crane03 cranectld节点：crane01 craned节点：crane02， crane03 1.环境准备 安装ca-certificates yum -y install ca-certificates （CentOS）安装ntp ntpdate同步时钟 yum -y install ntp ntpdate -y systemctl start ntpd systemctl enable ntpd timedatectl set-timezone Asia/Shanghai （Rocky Linux 9）安装并启用同步时钟服务chrony dnf install -y chrony timedatectl set-timezone Asia/Shanghai systemctl start chronyd systemctl enable chronyd 关闭防火墙，不允许关闭防火墙则考虑开放10011、10010、873端口 systemctl stop firewalld systemctl disable firewalld # 或者开放端口 firewall-cmd --add-port=10011/tcp --permanent --zone=public firewall-cmd --add-port=10010/tcp --permanent --zone=public firewall-cmd --add-port=873/tcp --permanent --zone=public # 重启防火墙(修改配置后要重启防火墙) firewall-cmd --reload 2.安装依赖包 # CentOS # 启用 EPEL 存储库 yum install -y epel-release yum update -y yum install -y tig tmux fish pdsh htop yum install -y openssl-devel libcgroup-devel \\ curl-devel boost169-devel boost169-static pam-devel \\ zlib-devel zlib-static # Rocky # 启用 EPEL 存储库 dnf install -y epel-release dnf update -y dnf install -y tig tmux fish pdsh htop dnf install -y openssl-devel libcgroup \\ curl-devel boost169-devel boost169-static pam-devel \\ zlib-devel 3.安装工具链 工具链版本： cmake版本 >= 3.24 libstdc++版本 >= 11 如果安装clang，版本 >= 15 如果安装g++，版本 >= 11 3.1.所有系统都适用 安装cmake，选择一个合适的源码存放位置，从github下载源码 wget https://github.com/Kitware/CMake/releases/download/v3.24.2/cmake-3.24.2-linux-x86_64.sh 执行cmake安装脚本 bash cmake-3.24.2-linux-x86_64.sh --prefix=/usr/local --skip-license 检查cmake安装是否成功 cmake --version #cmake version 3.24.2 3.2. CentOS7 3.2.1 命令行安装 gcc 13 wget https://ftp.gnu.org/gnu/gcc/gcc-13.2.0/gcc-13.2.0.tar.gz tar -zxvf gcc-13.2.0.tar.gz yum install -y bzip2 cd gcc-13.2.0 ./contrib/download_prerequisites mkdir build cd build/ ../configure -enable-checking=release -enable-languages=c,c++ -disable-multilib make -j 12 sudo make install 3.2.2 yum安装 安装其他工具链包 yum install -y ninja-build patch devtoolset-11 rh-git218 为了避免每次手动生效，可以在~/.bash_profile中设置 vim ~/.bash_profile source scl_source enable devtoolset-11 source scl_source enable rh-git218 然后重启终端，这时用gcc --version命令查询，可以看到版本已经是11.2系列了 gcc (GCC) 11.2.1 20220127 (Red Hat 11.2.1-9) Copyright (C) 2021 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 3.3. Ubuntu 20.04或包管理无libstdc++-11的系统 3.3.1. 编译安装gcc 由于Ubuntu 20.04官方仓库中libstdc++最大为10，通过手动编译安装g++-11来安装libstdc++-11 wget http://ftp.gnu.org/gnu/gcc/gcc-11.3.0/gcc-11.3.0.tar.gz tar -zxvf gcc-11.3.0.tar.gz sudo apt-get install bzip2 cd gcc-11.3.0 ./contrib/download_prerequisites mkdir build cd build/ ../configure -enable-checking=release -enable-languages=c,c++ -disable-multilib make -j 12 sudo make install 3.3.2. 指定clang选择手动安装的libstdc++ 由于没有指定--prefix，默认安装到/usr/local。如果希望clang和clang++能选择安装到这个目录的gcc-toolchain，需要通过clang和clang++的--gcc-toolchain的参数指定目录。 在cmake的命令行参数指定-DCMAKE_C_FLAGS_INIT=\"--gcc-toolchain=/usr/local\" -DCMAKE_CXX_FLAGS_INIT=\"--gcc-toolchain=/usr/local\" 3.4. Rocky 9 3.4.1. 安装GCC 13 wget https://ftp.gnu.org/gnu/gcc/gcc-13.1.0/gcc-13.1.0.tar.gz tar -xvf gcc-13.1.0.tar.gz dnf install -y gcc dnf install -y gcc-c++ dnf install -y bzip2 cd gcc-13.1.0 ./contrib/download_prerequisites mkdir build cd build ../configure --enable-languages=c,c++ --disable-multilib make -j$(nproc) make install 3.4.2. 安装构建工具 dnf groupinstall -y \"Development Tools\" dnf install -y autoconf automake libtool cmake dnf install -y systemd-devel dnf install -y gnuplot # ninja-build需开启Rocky-PowerTools.repo源 dnf install -y ninja-build patch #手动安装libcgroup git clone https://github.com/libcgroup/libcgroup.git cd libcgroup ./bootstrap.sh ./configure make make install 3.4.3. 其它可能的问题 Rocky Linux 9 中，libcgroup可能未包含在默认的软件包仓库中。可以尝试从源代码编译安装libcgroup 如果运行CMake查找libcgroup包未能找到它，需修改pkg-config 运行craned时，系统无法找到libcgroup.so.0这个共享库。通常，这是因为该库不在系统的默认库搜索路径中。 #安装构建依赖项 dnf groupinstall -y \"Development Tools\" dnf install -y autoconf automake libtool systemd-devel #从 GitHub 克隆 libcgroup 仓库 git clone https://github.com/libcgroup/libcgroup.git cd libcgroup #生成配置脚本 ./bootstrap.sh #配置构建，根据需要更改 --prefix 选项指定安装路径 ./configure --prefix=/usr/local #编译安装 make make install 4. 编译Crane程序 git config --global http.proxy http://crane:hf2lH9UUC3E0@192.168.1.1:7890 git config --global https.proxy http://crane:hf2lH9UUC3E0@192.168.1.1:7890 # 选择一个合适的位置克隆项目 git clone https://github.com/PKUHPC/CraneSched.git cd CraneSched mkdir build cd build # 首次编译需要下载第三方库，耗时较长 cmake -G Ninja -DCMAKE_C_COMPILER=/opt/rh/devtoolset-11/root/usr/bin/gcc -DCMAKE_CXX_COMPILER=/opt/rh/devtoolset-11/root/usr/bin/g++ -DBoost_INCLUDE_DIR=/usr/include/boost169/ -DBoost_LIBRARY_DIR=/usr/lib64/boost169/ .. ninja cranectld craned pam_crane # 仅安装到本机，craned节点需手动scp ninja install 5. Pam模块 不同系统不一样 5.1. CentOS 7 首次编译完成后需要将pam模块动态链接库放入系统指定位置 cp Crane/build/src/Misc/Pam/pam_Crane.so /usr/lib64/security/ #如果不行就在Pam目录下查找有可能生成so名字大小写不一致 cp Crane/build/src/Misc/Pam/pam_crane.so /usr/lib64/security/ 在 /etc/pam.d/sshd 中添加红色行： #%PAM-1.0 auth required pam_sepermit.so auth substack password-auth auth include postlogin # Used with polkit to reauthorize users in remote sessions -auth optional pam_reauthorize.so prepare account required pam_crane.so account required pam_nologin.so account include password-auth password include password-auth # pam_selinux.so close should be the first session rule session required pam_selinux.so close session required pam_loginuid.so # pam_selinux.so open should only be followed by sessions to be executed in the user context session required pam_selinux.so open env_params session required pam_namespace.so session optional pam_keyinit.so force revoke session include password-auth session optional pam_crane.so session include postlogin # Used with polkit to reauthorize users in remote sessions -session optional pam_reauthorize.so prepare 注意：session optional pam_crane.so必须位于 session include password-auth之后！因为password-auth中有pam_systemd.so这个模块，会导致sshd session被移入systemd:/user.slice这个cgroups中！ 目前不清楚systemd是否会定期轮询相应的进程是否被steal，待测试。 6.安装mongodb 安装数据库仅在需要存储数据的节点安装 修改mongodb的yum源: cat >> /etc/yum.repos.d/mongodb-6.0.2.repo 安装并添加mongodb开机启动 yum install mongodb-org -y # 添加开机启动 systemctl enable mongod systemctl start mongod 安装完mongod用户的home目录为/var/lib/mongo 利用openssl在/var/lib/mongo生成密钥文件 openssl rand -base64 756 | sudo -u mongod tee /var/lib/mongo/mongo.key sudo -u mongod chmod 400 /var/lib/mongo/mongo.key 创建用户 # 从mongodb6.0开始，mongo命令被mongosh命令取代 mongosh # 进入mongodb之后进行下列操作 use admin # user: 用户名 pwd：密码 roles：root 代表超級管理员权限 admin代表给admin数据库加的超级管理员 db.createUser({ user:'admin', pwd:'123456', roles:[{ role:'root',db:'admin'}] }) # 重启前先关闭服务器 db.shutdownServer() quit 修改/etc/mongod.conf配置文件，开启权限验证，并配置副本集配置 vim /etc/mongod.conf ...... #开启权限验证 security: authorization: enabled keyFile: /var/lib/mongo/mongo.key replication: #副本集名称,crane的配置文件要与此一致 replSetName: crane_rs 重新启动mongodb数据库 systemctl restart mongod 进入mongosh，初始化副本集 mongosh use admin db.auth（\"admin\",\"123456\"） # 如果不需要配置外部连接，并且副本集只有该主机一个节点，config可不配置 config = { \"_id\": \"crane_rs\", # 注意名称一致 \"members\": [ { \"_id\": 0, \"host\": \":27017\" # 建议这里填写部署数据集的节点主机名，默认为127.0.0.1 } # ... 其他节点（如果有的话） ] } rs.initiate() 7.运行项目 首先根据自身的集群情况在配置文件当中进行相应配置，配置文件样例保存在/etc/crane/config.yaml.example mkdir -p /etc/crane cp etc/config.yaml.example /etc/crane/config.yaml #上述命令报错就按照如下输入 cp etc/config.yaml /etc/crane/ vim /etc/crane/config.yaml 直接执行可执行文件启动 此时目录应该在项目根目录 cd build/src # Cranectld启动命令 CraneCtld/cranectld # Craned启动命令 Craned/craned Systemctl 启动服务 systemctl start cranectld # 控制节点守护程序服务 systemctl start craned # 计算节点守护程序服务 8. 其他节点环境部署 8.1 SCP命令版本 计算节点部署项目，无需编译项目，仅需复制相应的执行文件和配置文件即可 # 比如配置计算节点crane02 ssh crane02 \"mkdir -p /etc/crane\" scp /usr/local/bin/craned crane02:/usr/local/bin/ scp /etc/systemd/system/craned.service crane02:/etc/systemd/system/ scp /etc/crane/config.yaml crane02:/etc/crane/ 8.2 PDSH版本 如果没安装pdsh，安装pdsh yum install -y pdsh 更新cranectld # 注意需位于编译路径下执行 pdsh -w cranectl systemctl stop cranectld pdcp -w cranectl src/CraneCtld/cranectld /usr/local/bin pdsh -w cranectl systemctl start cranectld 更新craned pdsh -w crane0[1-4] systemctl stop craned pdcp -w crane0[1-4] Craned/craned /usr/local/bin pdsh -w crane0[1-4] systemctl start craned 9. 其他配置 Fish shell cd /etc/yum.repos.d/ wget https://download.opensuse.org/repositories/shells:/fish:/release:/3/CentOS_7/shells:fish:release:3.repo yum makecache yum install -y fish Nix 见 https://mirrors.tuna.tsinghua.edu.cn/help/nix/ "},"config/Crane-FrontEndConfiguration.html":{"url":"config/Crane-FrontEndConfiguration.html","title":"3.2 CraneSched 前端环境配置","keywords":"","body":"CraneSched-FrontEnd 项目环境配置 1.安装go语言 cd download/ wget https://golang.google.cn/dl/go1.17.3.linux-amd64.tar.gz tar -C /usr/local -xzf go1.17.3.linux-amd64.tar.gz # 在 /etc/profile中设置环境变量 export GOROOT=/usr/local/go export GOPATH=/usr/local/gopath export PATH=$PATH:/$GOROOT/bin:$GOPATH/bin source /etc/profile # 加载环境变量 go version #设置代理 go env -w GOPROXY=https://goproxy.cn,direct #开启go mod管理 go env -w GO111MODULE=on # 安装插件 go install google.golang.org/protobuf/cmd/protoc-gen-go@latest go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest 2.安装protoc wget https://github.com/protocolbuffers/protobuf/releases/download/v3.19.4/protobuf-all-3.19.4.tar.gz tar -xzf protobuf-all-3.19.4.tar.gz cd protobuf-3.19.4 ./configure -prefix=/usr/local/ make && make install protoc --version # libprotoc 3.19.4 3.拉取项目 git clone https://github.com/PKUHPC/Crane-FrontEnd.git # 克隆项目代码 4.编译项目 生成proto文件 cd Crane-FrontEnd/ make all 5.部署前端命令 5.1. 本地更新 cp ./bin/* /usr/local/bin/ 5.2. 用pdsh远端更新 以下用demo集群为例： pdcp -w login -w crane0[1-4] -w cranectl ./bin/* /usr/local/bin/ 5.3. 部署cfored 在登录节点和计算节点部署 systemctl stop firewalld systemctl disable firewalld # 上述两条命令不成功需要执行下面命令 #或者开放端口 firewall-cmd --add-port=10012/tcp --permanent --zone=public # 重启防火墙(修改配置后要重启防火墙) firewall-cmd --reload # 在Crane-FrontEnd/目录下 # 本地节点 cp ./etc/cfored.service /etc/systemd/system/ # 远端节点 pdcp -w login -w crane0[1-4] -w cranectl ./etc/cfored.service /etc/systemd/system/ # 启动cfored systemctl start cfored 5.4. 部署cwrapper 在登录节点和计算节点上，用cwrapper命令将鹤思命令与slurm常用命令关联： cat > /etc/profile.d/cwrapper.sh "},"command/":{"url":"command/","title":"4 CraneSched使用教程","keywords":"","body":"CraneSched使用教程 slurm是目前高性能计算调度领域使用最为广泛的调度系统，用户众多，为了减少用户使用鹤思智能调度系统的学习成本，鹤思在前端用户操作指令的设计时，主要借鉴Slurm的指令原型，便于用户快速从Slurm系统切换到鹤思调度系统。此外，鹤思在用户指令的使用提示方面进行了全方位的体验提升，用户可按照系统的帮助提示一步步完成操作。目前鹤思智能调度系统已经完成查看节点与分区状态、提交批处理作业、查看未结束的作业、取消作业、查看分区/节点状态、管理QoS/用户/账户信息、查看所有已结束/未结束的作业信息等功能的研发。 CraneSched有以下9个常用指令，请点击查看更详细使用信息 cinfo： 查看节点与分区状态 cbatch： 提交批量处理作业 crun： 提交交互式任务 calloc： 提交交互式任务 cqueue： 查看作业队列 ccancel： 取消运行或提交的作业 ccontrol：查看/修改分区和节点状态 cacctmgr： 查看和调整用户/账号信息 cacct： 查看作业信息 "},"command/cinfo.html":{"url":"command/cinfo.html","title":"4.1 cinfo 查看节点与分区状态","keywords":"","body":"cinfo 查看节点与分区状态 cinfo可查询各分区节点的队列资源信息。 查看分区节点状态： cinfo cinfo运行结果展示 主要输出项 PARTITION：分区名 AVAIL： 分区状态 UP： 可用 DOWN： 不可用 NODES：节点数 STATE：节点状态 idel： 空闲 mix： 节点部分核心可以使用 alloc： 节点已被占用 down： 节点不可用 NODELIST： 节点列表 主要参数 -h/--help：显示帮助 -C/--config string：配置文件路径(默认为 \"/etc/crane/config.yaml\") -d/--dead：只显示无响应节点 -i/--iterate uint：指定间隔秒数刷新查询结果。如 -i=3 表示每隔三秒输出一次查询结果 -n/--nodes string：显示指定节点信息，多个节点用逗号隔开。例：cinfo -n dby01,dby02 -p/--partition string：显示指定分区信息，多个分区用逗号隔开。例：cinfo -p CPU,GPU -r/--responding：只显示有响应节点 -t/--states string：仅显示状态的信息。状态可以为(不区分大小写): IDLE, MIX, ALLOC和DOWN 例 cinfo -h cinfo -d cinfo -i 3 cinfo -n dby01,dby02 cinfo -p GPU,CPU cinfo -r cinfo -t IDLE "},"command/cbatch.html":{"url":"command/cbatch.html","title":"4.2 cbatch 提交批处理作业","keywords":"","body":"cbatch 提交批处理作业 cbatch主要是将用户描述整个计算过程的脚本传递给作业调度系统，并为作业分配作业号，等待作业调度系统为其分配资源并执行。 CraneSched系统中必须有用户和账号才能提交作业，添加用户和账户请参考cacctmgr教程。 首先介绍一个简单的单节点作业的例子: 下列作业将申请一个节点，一个CPU核心，并在计算节点上运行hostname并退出 #!/bin/bash #CBATCH --ntasks-per-node 1 #CBATCH --node 1 #CBATCH -c 1 #CBATCH --mem 20M #CBATCH --time 0:3:1 #CBATCH -o job.out #CBATCH -p CPU #CBATCH -J Test_Job hostname 假设上面作业脚本的文件名为crane_submit.sh，通过cbatch命令提交： cbatch crane_submit.sh cbatch运行结果展示 主要参数： --help/-h：显示帮助 -A, --account string：提交作业的账户 --chdir string：作业工作路径 -C, --config string：配置文件路径(默认 \"/etc/crane/config.yaml\") -c, --cpus-per-task float：每个节点申请的CPU核心数 -J, --job-name string：作业名 --mem string：每个节点申请的内存大小 -N, --nodes uint32：申请的节点数量 --ntasks-per-node uint32：每个节点上运行的任务数量 -o, --output string：指定作业的标准输出重定向 -p, --partition string：作业使用的分区/队列 -Q, --qos string：指定作业使用的qos名称 -t, --time string：作业的最长运行时间 --repeat：以指定的重复次数提交作业，默认为1 -w, --nodelist：提交作业到指定节点运行 -x, --exclude：提交的作业排除某些指定节点运行 --get-user-env：获取用户的环境变量 --export：设置环境变量 --mail-type, --mail-user：设置邮件提醒功能 --mail-user：设置邮件提醒的收件地址 --mail-type：设置邮件提醒在任务运行的哪些阶段发送（可用的值包括：NONE、BEGIN、END、FAIL、ALL，默认为 None 即不发送提醒） 注意：使用邮件提醒功能必须预先配置 Linux 的 mail 命令，同时在 CraneSched 后端启用邮件功能，否则邮件相关参数将被忽略。 例如： cbatch --mail-type=ALL --mail-user=foo@bar.com test.job 常用环境变量 变量名 说明 CRANE_JOB_NODELIST 作业分配的节点列表 %j 作业号 下面介绍提交一个跨节点多核心的例子： 下列作业将在三个节点上运行，每个节点使用4个CPU核心。 #!/bin/bash #CBATCH -o crane_test%j.out #CBATCH -p CPU #CBATCH -J \"crane_test\" #CBATCH --node 3 ##CBATCH --ntasks-per-node 4 #CBATCH -c 4 #CBATCH --time 50:00:00 # 生成作业分配的节点的machinefile echo \"$CRANE_JOB_NODELIST\" | tr \";\" \"\\n\" > crane.hosts #加载MPI运行环境 module load mpich/4.0 #执行跨节点并行任务 mpirun -n 13 -machinefile crane.hosts helloWorld > log "},"command/crun.html":{"url":"command/crun.html","title":"4.3 crun 提交交互式任务","keywords":"","body":"crun 提交交互式任务 crun使用命令行指定的参数申请资源并在计算节点启动指定的任务，用户的输入将被转发到计算节点上对应的任务，任务的输出将被转发回用户终端。crun需要在有cfored运行的节点上启动。 crun只支持通过命令行指定请求参数，支持的命令行选项： --help/-h：显示帮助 -A, --account string：提交作业的账户 --chdir string：任务工作路径 -C, --config string：配置文件路径(默认 \"/etc/crane/config.yaml\") -c, --cpus-per-task float：每个节点申请的CPU核心数 -J, --job-name string：作业名 --mem string：每个节点申请的内存大小 -N, --nodes uint32：申请的节点数量 --ntasks-per-node uint32：每个节点上运行的任务数量 -p, --partition string：作业使用的分区/队列 -Q, --qos string：指定作业使用的qos名称- -t, --time string：作业的最长运行时间 -w, --nodelist：提交作业到指定节点运行 -x, --exclude：提交的作业排除某些指定节点运行 -D, --debug-level：日志输出等级 在一秒内两次ctrl+c发送sigint信号、使用ccancel取消任务、或者节点上的任务进程退出会结束任务。 在CPU分区，申请两个节点，一个CPU核心，200M内存，并运行bash程序： crun -c 1 --mem 200M -p CPU -N 2 /usr/bin/bash 运行结果： crun还可以在calloc任务内嵌套启动，将自动继承calloc任务的所有资源。不需要指定除需要运行的程序外其他参数。 "},"command/calloc.html":{"url":"command/calloc.html","title":"4.4 calloc 提交交互式任务","keywords":"","body":"calloc 提交交互式任务 calloc 使用命令行指定的参数申请资源，任务启动时，会进入新的用户终端，用户需要自行登陆到计算节点并启动任务。calloc需要在有cfored运行的节点上启动。 calloc 只支持通过命令行指定请求参数，支持的命令行选项： --help/-h：显示帮助 -A, --account string：提交作业的账户 --chdir string：任务工作路径 -C, --config string：配置文件路径(默认 \"/etc/crane/config.yaml\") -c, --cpus-per-task float：每个节点申请的CPU核心数 -J, --job-name string：作业名 --mem string：每个节点申请的内存大小 -N, --nodes uint32：申请的节点数量 --ntasks-per-node uint32：每个节点上运行的任务数量 -p, --partition string：作业使用的分区/队列 -Q, --qos string：指定作业使用的qos名称- -t, --time string：作业的最长运行时间 -w, --nodelist：提交作业到指定节点运行 -x, --exclude：提交的作业排除某些指定节点运行 -D, --debug-level：日志输出等级 退出calloc新启动的终端将结束任务。 在CPU分区，申请两个个节点，一个CPU核心，200M内存 calloc -c 1 --mem 200M -p CPU -N 2 运行结果： "},"command/cqueue.html":{"url":"command/cqueue.html","title":"4.5 cqueue 查看作业队列","keywords":"","body":"cqueue 查看作业队列 cqueue可以查看队列中的作业信息。 查看集群中所有队列的作业信息（包括状态pending、running、cancelled），默认输出100条信息。 cqueue cqueue运行结果展示 主要输出项 JobId：作业号 Partition：作业所在分区 Name：作业名 User：作业所属用户 Account：作业所属账户 Status：作业状态 Type： 作业类型 TimeLimit：作业时间限制 Nodes：作业所分配节点数 NodeList：作业运行的节点名 主要参数 --help：显示帮助 --config/-C：配置文件路径 --noHeader/-N：输出隐藏表头 --start/-S：显示作业的开始时间（pending作业显示预期开始时间） --job/-j：指定查询作业号，指定多个作业号时用逗号隔开。如 -j=2,3,4 --name/-n：指定查询作业名，指定多个作业名时用逗号隔开。 --qos/-q：指定查询作业的QoS，指定多个QoS时用逗号隔开。 --state/-t：指定查询作业状态，指定多个状态时用逗号隔开。 --user/-u：指定查询作业所属用户，指定多个用户时用逗号隔开。 --Account/-A：指定查询作业所属账户，指定多个账户时用逗号隔开。 --iterate/-i：指定间隔秒数刷新查询结果。如 -i=3表示每隔三秒输出一次查询结果 --partition/-p：指定查询作业所在分区，指定多个分区时用逗号隔开。 --MaxVisibleLines/-m：指定输出结果的最大条数。如-m=500表示最多输出500行查询结果 --format/-o：以指定格式输出结果表，可以指定输出指定列以及列宽。 例cqueue -h cqueue -N cqueue -S cqueue -j 65,61,63 cqueue -q normal cqueue -t Pending cqueue -u root cqueue -A ROOT cqueue -i 3 cqueue -p CPU cqueue -m 3 cqueue -o=\"%n %u %.5j %.5t %.3T %.5T\" format中的指定列的对应缩写对照： j-TaskId；n-Name；t-State；p-Partition；u-User；a-Account；T-Type；I-NodeIndex；l-TimeLimit；N-Nodes "},"command/ccancel.html":{"url":"command/ccancel.html","title":"4.6 ccancel 取消运行或提交的作业","keywords":"","body":"ccancel 取消作业 ccancel可以终止正在运行或者在排队中的作业。 主要参数 --help/-h: 显示帮助 -A, --account string：取消账户下的任务 -C, --config string：配置文件路径(默认 \"/etc/crane/config.yaml\") -n, --name string：仅使用任务名称取消任务 -w, --nodes strings：取消节点上运行的任务 -p, --partition string：取消分区上运行的任务 -t, --state string：取消某状态的任务。有效的任务状态是 PENDING(PD)、RUNNING(R)。任务状态不区分大小写 -u, --user string：取消特定用户提交的任务 例 ccancel -w crane02 ccancel -t Pending 取消作业号为280的作业： ccancel 280 ccancel运行结果展示 取消作业之后，如果被分配节点上没有用户的其他作业，作业调度系统会终止用户在所分配节点的所有进程，并取消用户在所分配节点上的ssh权限。 "},"command/ccontrol.html":{"url":"command/ccontrol.html","title":"4.7 ccontrol 查看/修改分区和节点状态","keywords":"","body":"ccontrol 查看/修改分区和节点状态 ccontrol可以查看/修改分区和节点的状态。 主要命令 help：显示帮助 add：添加一个分区或者节点 delete：删除一个分区或者节点 show：显示实体的状态，默认为所有记录 update：修改作业/分区/节点信息 hold：暂停作业调度 release：继续作业调度 1. 查看分区状态 ccontrol show partition ccontrol show partition运行结果展示 主要输出项 PartitionName：分区名 State：分区状态 TotalNodes：分区节点数目 AliveNodes：分区中可运行的节点数目 TotalCpus：分区中所有节点总CPU数目 AvailCpus：分区中所有可以使用的CPU数目 AllocCpus：分区中已经被分配的CPU数目 FreeCpus：分区中空闲的CPU数目 TotalMem：分区节点的总内存 AvailMem：分区中当前可以使用的内存大小 AllocMem：分区中已分配的内存大小 FreeMem：分区中空闲的内存大小 HostList：分区中所有节点的节点名列表 2. 查看节点状态 ccontrol show node ccontrol show node运行结果展示 主要输出项 NodeName：节点名 State：节点状态 IDLE：节点空闲，可使用 DOWN：节点宕机，不可用 CPUs：节点CPU数目 AllocCpus：节点已分配的CPU数目 FreeCpus：节点空闲的CPU数目 RealMemory：节点的实际内存大小 AllocMem：节点已经分配的内存大小 FreeMem：节点空闲的内存大小 Patition：节点所属分区 RunningTask：节点上正在运行的作业数量 3. 查看作业状态 ccontrol show job ccontrol show job 运行结果展示 主要输出项 JobId：作业号 JobName：作业名 UserId：作业所属用户 GroupId：分组id Account：作业所属账户 JobState：作业状态 RunTime：作业运行时间 TimeLimit：作业运行时间限制 SubmitTime：作业提交时间 StartTime：作业开始时间 EndTime：作业结束时间 Partition：作业所属分区 Nodelist：作业运行的节点 NumNodes：节点数量 4. 修改作业信息 ccontrol update job 主要参数 --job/-J：指定修改的作业号 --time-limit/-T：修改时间限制 --priority/-P：修改时间限制 5. 暂停作业调度 主要参数 --time-limit/-T：修改时间限制 ccontrol hold 1 #暂停调度编号为1的任务 ccontrol hold 1,2,3 -t 0:0:5 #暂停调度编号为1,2,3的任务5秒钟（随后解除暂停） hold 接受 job_id 的方式与 ccancel 相同，要求为逗号分隔的任务编号。 只能 hold pending 任务。 如果此前有设置解除暂停的定时器，该操作会取消原有的定时器。 使用 cqueue 查询时，如果任务被 hold，Node(Reason) 一列会显示 \"Held\"。 6. 继续作业调度 ccontrol release 1,2,3 如果此前有设置解除暂停的定时器，该操作会取消原有的定时器。 只能 release pending 任务。 7. 添加一个节点 ccontrol add node 主要参数 -c, --cpu：节点的核心数 -M, --memory：节点的内存大小，默认是MB -N, --name：节点名称 -P, --partition：节点所属的分区，可以不指定，那么就不属于任何一个分区 8. 添加一个分区 ccontrol add partition 主要参数 -A, --allowlist：分区允许的账户列表 -D, --denylist：分区禁止的账户列表，和上面只能设置其中一个，每次设置后以最后设置的为准 -N, --name：分区的名称 --nodes：分区的节点列表，可以用聚合形式cn[01-15]，可以用独立节点名cn01,cn02，也可以混合写，注意参数用\"\"包成一个字符串 -P, --priority：分区的优先级，目前不支持优先级为0 9. 删除一个节点 ccontrol delete node [name] 将节点从所有分区删除，如果节点上面还有作业正在运行，则询问用户是否需要杀死作业来强制删除。 10. 删除一个分区 ccontrol delete partition [name] 删除一个分区，该分区上的节点如果还有正在运行的作业，依然可以继续运行不受影响，但是由于分区被删除，不能再往该分区调度作业。 11. 修改节点信息 ccontrol update node 主要参数 -c, --cpu：节点的核心数 -M, --memory：节点的内存大小，默认是MB -N, --name：节点名称 -P, --partition：节点所属的分区 以下参数和上面参数不能一起设置，下面参数用于修改节点状态 -R, --reason：Set the reason of this state change -S, --state：Set the node state 12. 修改分区信息 ccontrol update partition 主要参数 -A, --allowlist：分区允许的账户列表 -D, --denylist：分区禁止的账户列表，和上面只能设置其中一个，每次设置后以最后设置的为准 -N, --name：分区的名称 --nodes：分区的节点列表，可以用聚合形式cn[01-15]，可以用独立节点名cn01,cn02，也可以混合写，注意参数用\"\"包成一个字符串 -P, --priority：分区的优先级，目前不支持优先级为0 "},"command/cacctmgr.html":{"url":"command/cacctmgr.html","title":"4.8 cacctmgr 查看和调整用户/账号信息","keywords":"","body":"cacctmgr 管理用户/账户信息 cacctmgr 可以管理账户/用户信息，包括添加账户/用户、删除账户/用户、查找账户/用户。 Crane作业调度系统中有三个用户角色： 系统管理员（Admin）：一般为root用户，可以增删查改任何账户和用户信息 平台管理员（Operator）：对账户系统具有完全权限，可以查看private data 账户调度员（Coordinator）：对与自身同一账户下的用户以及对自身账户的子账户具有操作权限，包括添加用户 普通用户(None)：除了查询功能外不具备其他权限，能够查询与自身同一账户下的信息，不可以修改所有用户和账户信息 主要参数 -h/--help：显示帮助 -C, --config string：配置文件路径（默认为\"/etc/crane/config.yaml\"） 主要命令 help：显示帮助 add：添加实体（实体包括QoS、账户、用户） block：禁用该实体，使其无法使用 delete：删除实体 find：找到特定实体 modify：修改实体 show：显示一类实体的所有记录 unblock：解除禁用 1. 添加qos 主要参数 -D, --description string：qos描述信息 -h, --help：帮助 -c, --max_cpus_per_user uint32：默认为10 -J, --max_jobs_per_user uint32 -T, --max_time_limit_per_task uint：以秒为单位的时间（默认3600） -N, --name string：qos的名称 -P, --priority uint32：默认为1000 例 cacctmgr add qos -N=test -D=\"test qos\" 2. 添加账户 主要参数 -Q, --default_qos string：账户默认qos -D, --description string：账号描述信息 -h, --help：帮助 -N, --name string：账户的名称 -P, --parent string：此账户的父账户 -p, --partition strings：该账号可以访问的分区列表 -q, --qos_list strings：账号可以访问的qos列表 例：（添加账户PKU并添加PKU的子账户ComputingCentre） cacctmgr add account -N=PKU -D=school -p=CPU,GPU -q=test cacctmgr add account -N=ComputingCentre -D=department -P=PKU 3. 添加用户 系统管理员可以添加任意账户的用户， 账户管理员可以添加同一账号下的新用户。添加的用户需要先有uid（先使用useradd在linux系统添加该用户）。 主要参数 -A, --account string：此用户所属的父账户 -c, --coordinate：设置用户是否为父账号的账户调度员（coordinator） -h, --help：帮助 -L, --level string：设置用户权限(none/operator/admin) (默认为 \"none\") -N, --name string：用户的名称 -p, --partition strings：该用户可以访问的分区列表 例 useradd CS cacctmgr add user -N=CS -A=PKU -p=CPU,GPU -L=admin # -p参数指明用户可用分区为CPU和GPU（分区必须同时为父账户PKU的可用分区），分区的allowed_qos_list与default_qos信息不支持指定，默认从父账户PKU中继承 cacctmgr add user -N=lab -A=ComputingCentre # 未指明-p参数，partition与qos信息都从父账户ComputingCentre中继承 4. 删除用户 系统管理员可以删除任意账户下的用户， 账户管理员可以删除同一账户下的新用户。 cacctmgr delete user lab 5. 删除账户 仅系统管理员可以删除账户，删除账户时会检查账户下是否还有子账户或者用户，如果有则不允许删除，防止产生游离的用户，需要将其子账户和用户都设置在新账户下。 cacctmgr delete account ComputingCentre 6. 删除qos cacctmgr delete qos test 7. 阻止用户或账户 主要命令 account：阻止账户 user：阻止账户下的用户 cacctmgr block user lab -A=ComputingCentre cacctmgr block account ComputingCentre 8. 解除阻止用户或账户 主要命令 account：阻止账户 user：阻止账户下的用户 cacctmgr unblock user lab -A=ComputingCentre cacctmgr unblock account ComputingCentre 9. 查找用户 所有用户均可以使用查询功能 cacctmgr find user lab cacctmgr find user CS 10. 查找账户 cacctmgr find account ComputingCentre cacctmgr find account PKU 11. 查找qos cacctmgr find qos test 12. 修改账户 系统管理员可以修改任意信息，账户管理员可以修改本身账户的信息，但不能更改账户的父账户。 cacctmgr modify account -name=China -describe=Splendid 主要参数 --add_allowed_partition string：将新项添加到允许的分区列表 --add_allowed_qos_list strings：将新项添加到允许的qos列表 -Q, --default_qos string：修改账户默认qos --delete_allowed_partition string：从允许的分区列表中删除特定项目 --delete_allowed_qos_list strings：从允许的qos列表中删除特定项目 -D, --description string：修改账户的描述信息 -F, --force：强制操作 -h, --help：帮助 -N, --name string：需要进行修改的账户名称 --set_allowed_partition strings：设置允许的分区列表的内容 --set_allowed_qos_list strings：设置允许的qos列表的内容 例： cacctmgr modify account -N=ComputingCentre -D=\"Located in PKU\" 13. 修改用户 系统管理员可以修改任意信息，账户管理员可以修改同账户下用户的信息，但不能更改用户的账户。 主要参数 -A, --account string：设置用户使用的帐号 --add_allowed_partition strings：将新项添加到允许的分区列表 --add_allowed_qos_list string：将新项添加到允许的qos列表 -L, --admin_level string：设置用户管理权限（none/operator/admin） -Q, --default_qos string：修改账户默认qos --delete_allowed_partition strings：从允许的分区列表中删除特定项目 --delete_allowed_qos_list string：从允许的qos列表中删除特定项目 -F, --force：强制操作 -h, --help：帮助 -N, --name string：需要进行修改的用户名称 -p, --partition string：被修改的分区，如果不显式设置该参数，默认修改所有分区 --set_allowed_partition strings：设置允许的分区列表的内容 --set_allowed_qos_list strings：设置允许的qos列表的内容 例： cacctmgr modify user -N=lab -A=ComputingCentre -L=operator --delete_allowed_partition GPU 14. 修改qos 系统管理员可以修改任意信息，账户管理员可以修改同账户下用户的信息，但不能更改用户的账户。 主要参数 -D, --description string：修改qos的描述信息 -h, --help：帮助 -c, --max_cpus_per_user uint32：(默认10) -J, --max_jobs_per_user uint32 -T, --max_time_limit_per_task uint：以秒为单位的时间（默认 3600） -N, --name string：需要进行修改的qos名称 -P, --priority uint32：(默认1000) 15. 显示账户树 系统管理员会显示数据库所有根账户的账户树，账户管理员和用户会显示本身账户的账户树。 cacctmgr show accounts 16. 显示用户 系统管理员会显示所有用户，账户管理员和用户会显示同一账户下的所有用户。 cacctmgr show users "},"command/cacct.html":{"url":"command/cacct.html","title":"4.9 cacct 查看作业信息","keywords":"","body":"cacct 查看作业信息 cacct可以查看队列中的作业信息。 查看集群中所有队列的作业信息（包括所有状态），默认输出100条信息。 cacct cacct运行结果展示 主要输出项 TaskId：作业号 TaskName：作业名 Partition：作业所在分区 Account：作业所属账户 AllocCPUs：作业分配的CPU数量 State：作业状态 ExitCode：作业状态码 主要参数 --MaxVisibleLines/-m：指定输出结果的最大条数。如-m=500表示最多输出500行查询结果 -A/--account string：指定查询作业的所属账户，指定多个账户时用逗号隔开。 -C/--config string：配置文件路径(默认为 \"/etc/crane/config.yaml\") -E/--endtime string：指定查询该时间之前结束的作业，例：cacct -E=2023-03-14T10:00:00 -o/--format string：以指定格式输出结果表，可以指定输出指定列以及列宽。 --help/-h：显示帮助 -j/ --job string：指定查询作业号，指定多个作业号时用逗号隔开。如 -j=2,3,4 -n/ --name string：指定查询作业名，指定多个作业名时用逗号隔开。 --noHeader/-N：输出隐藏表头 -S/--startime string：指定查询该时间之后开始的作业，例：cacct -S=2023-03-14T10:00:00 -u/--user string：指定查询某个用户的作业，指定多个用户时用逗号隔开。 例 cacct cacct -h cacct -N cacct -S=2023-03-14T10:00:00 cacct -E=2023-05-07T10:00:00 cacct -j=25,24,23 cacct -u=root cacct -A=ROOT cacct -m=10 cacct -o=\"TaskId,TaskName%30,Partition,Account,State\" "}}