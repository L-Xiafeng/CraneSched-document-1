{"./":{"url":"./","title":"1 Crane简介","keywords":"","body":"Crane 简介 鸣鹤（Crane）是北京大学高性能计算校级公共平台自主研发的分布式智算调度系统，团队在总结高性能公共平台运行近六年的管理和维护经验之后，从高性能计算任务调度的资源管理、资源查看、作业提交、作业查询和资源隔离等作业调度系统最基本的需求出发，结合云计算的作业调度场景，采用C++、go等语言进行开发，完全自主研发的融合高性能计算和云计算调度为一体的开源分布式智算调度系统。 Crane开源地址：Crane，欢迎开发者一起加入。 Crane 设计理念 功能强大：支持高性能计算 + 云计算 高度可伸缩：支持百万核心集群规模 + 可同时处理10万条作业 易使用：用户友好 + 管理员易使用 安全：通信加密 + 故障率低不丢作业 高度可容错：无单点故障 + 快速故障恢复 易部署 Crane 架构 Cranectld是调度系统的“大脑”，负责集群节点生命周期的管理、作业队列的调度及管理、节点资源管理及调度，处理来自用户指令的作业提交、修改、查询等请求。 Craned是部署在计算节点上的守护进程，主要用来监控节点资源及作业状态，接受用户的各种指令，并将其发送给Cranectld，并向用户传送Cranectld的返回结果。 在设计Craned的时候，综合考量高性能计算和云计算服务的特点与不同，在资源分配的时候，设计了Resouces Manager这个对象，当 用户提交高性能计算作业时，调用Cgroup Manager这个组件，用来为高性能计算服务分配资源，并用Cgroup来隔离作业资源。 用户提交云计算作业时，调用Container Manager这个组件，基于K8S为云计算作业分配资源并打包APP 容器，并对容器生命周期进行管理。 Crane 应用场景 Crane支持高性能计算+云计算的复杂分布式计算场景，结合“东数西算”时代背景，将分布于全国各地的集群通过一个云端联通，Crane通过调度算法将用户的作业提交到最“空闲”的集群上，充分利用各集群资源，减少用户排队时间。 "},"features.html":{"url":"features.html","title":"2 Crane功能和特点","keywords":"","body":"Crane功能和特点 资源管理功能 资源查看 资源调度 资源管理（增加/减少/节点状态变化等） 资源审计（节点状态变化事件记录） 作业管理功能 作业提交 作业取消 作业修改，时间延长等 作业状态查询 作业审计 特点 完全开源 支持高性能计算与云计算两种作业模式 无单点故障，容错性高 资源和节点状态可持续化，宕机之后重启自动恢复 高度可扩展性，可以同时支持提交/取消/管理多个独立作业 高性能，每秒可处理多个作业，为作业分配资源并运行 常用命令 cinfo： 查看节点与分区状态 cbatch： 提交批量处理作业 cqueue： 查看作业队列 ccancel： 取消作业 ccontrol:查看分区和节点状态 cacctmgr： 查看和调整用户/账号信息 常用术语 job: 作业 node: 计算节点 core: CPU核 tasks： 任务数，一般一个任务使用一个CPU核，可理解为作业所需的CPU核数 partition: 分区 user: 用户名 account: 账户 stdout: 标准输出文件，程序运行正常时输出信息的文件，一般指输出到屏幕的信息 stderr: 标准错误文件，程序运行错误时输出信息的文件，一般指输出到屏幕的信息 "},"config/Crane Configuration.html":{"url":"config/Crane Configuration.html","title":"3.1 Crane 后端环境配置","keywords":"","body":"Crane 项目环境配置 以下内容为配置代码编译环境，在编译项目的节点执行 1.环境准备 安装ntp ntpdate同步时钟 yum -y install ntp ntpdate -y systemctl start ntpd systemctl enable ntpd timedatectl set-timezone Asia/Shanghai 关闭防火墙，不允许关闭防火墙则考虑开放10011、10010、873端口 systemctl stop firewalld systemctl disable firewalld # 或者开放端口 firewall-cmd --add-port=10011/tcp --permanent --zone=public firewall-cmd --add-port=10010/tcp --permanent --zone=public firewall-cmd --add-port=873/tcp --permanent --zone=public # 重启防火墙(修改配置后要重启防火墙) firewall-cmd --reload 2.安装依赖包 yum install -y epel-release pv openssl-devel libcgroup-devel curl-devel boost169-devel boost169-static 3.安装工具链 安装C++11 # Install CentOS SCLo RH repository: yum install -y centos-release-scl-rh # Install devtoolset-11 rpm package: yum install -y devtoolset-11 # 第三步就是使新的工具集生效 scl enable devtoolset-11 bash 这时用gcc --version查询，可以看到版本已经是11.2系列了 $ gcc --version gcc (GCC) 11.2.1 20220127 (Red Hat 11.2.1-9) Copyright (C) 2021 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 为了避免每次手动生效，可以在.bashrc中设置，此文件中修改对当前用户永久生效 vim ~/.bashrc # 在最后一行加上 source /opt/rh/devtoolset-11/enable or source scl_source enable devtoolset-11 # 使环境变量生效 source ~/.bashrc 安装cmake和ninja 选择一个合适的源码存放位置，从github下载源码 wget https://github.com/ninja-build/ninja/releases/download/v1.10.2/ninja-linux.zip wget https://github.com/Kitware/CMake/releases/download/v3.21.3/cmake-3.21.3.tar.gz 解压编译安装，首次编译时间较长，请耐心等待 unzip ninja-linux.zip cp ninja /usr/local/bin/ tar -zxvf cmake-3.21.3.tar.gz cd cmake-3.21.3 ./bootstrap gmake gmake install 检查安装是否成功 cmake --version #cmake version 3.21.3 # #CMake suite maintained and supported by Kitware (kitware.com/cmake). 报错 CMake Error: Could not find CMAKE_ROOT !!! CMake has most likely not been installed correctly. Modules directory not found in /usr/local/bin Segmentation fault 出现这种情况一般情况下是因为我们在安装cmake之前执行过cmake命令，终端的哈希表会记录下执行过的命令的路径，相当于缓存。第一次执行命令shell解释器默认的会从PATH路径下寻找该命令的路径，当我们第二次使用该命令时，shell解释器首先会查看哈希表，没有该命令才会去PATH路径下寻找。 所以哈希表可以大大提高命令的调用速率，但是CMake Error: Could not find CMAKE_ROOT错误的原因也出在这里，如果我们之前在这个终端执行过cmake命令，那么哈希表就会自动记录下之前版本cmake的路径，我们可以通过输入hash -l查看，如下所示： [root@cn17 cmake-3.21.3]# hash -l builtin hash -p /usr/bin/wget wget builtin hash -p /usr/bin/cmake cmake 所以当我们更新了cmake以后，当我们输入cmake相关命令时，shell解释器便会去哈希表里面查找之前版本cmake的路径，然后便产生了错误。 此时我们可以重新开一个终端，也可以在该终端执行hash -r命令来清除哈希表的内容，然后再执行cmake --version命令。 4.安装mongodb 安装数据库仅在需要存储数据的节点安装 # 下载并解压安装包 wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel70-5.0.9.tgz tar -zxvf mongodb-linux-x86_64-rhel70-5.0.9.tgz # 重命名 mv mongodb-linux-x86_64-rhel70-5.0.9 /opt/mongodb # 添加环境变量 vim /etc/profile 在配置文件中添加如下内容（路径应对应mongodb安装路径） export MONGODB_HOME=/opt/mongodb export PATH=$PATH:${MONGODB_HOME}/bin # 使环境变量生效 source /etc/profile # 创建db目录和log目录 cd /opt/mongodb mkdir -p ./data/db mkdir -p ./logs touch ./logs/mongodb.log 创建mongodb.conf配置文件，内容如下： vim mongodb.conf #端口号 port=27017 #db目录 dbpath=/opt/mongodb/data/db #日志目录 logpath=/opt/mongodb/logs/mongodb.log #后台 fork=true #日志输出 logappend=true #允许远程IP连接 bind_ip=0.0.0.0 #开启权限验证 #auth=true 启动测试 mongod --config /opt/mongodb/mongodb.conf mongo 创建用户 use admin db.createUser({ user:'admin', # 用户名 pwd:'123456', # 密码 roles:[{ role:'root',db:'admin'}] #root 代表超級管理员权限 admin代表给admin数据库加的超级管理员 }) db.shutdownServer() # 重启前先关闭服务器 修改/opt/mongodb/mongodb.conf配置文件，将权限验证的注释放开 vim /opt/mongodb/mongodb.conf ...... #开启权限验证 auth=true 重新启动mongodb数据库 mongod --config /opt/mongodb/mongodb.conf 编辑开机启动 vi /etc/rc.local # 加入如下语句，以便启动时执行： mongod --config /opt/mongodb/mongodb.conf 5.编译Crane程序 # 由于便于项目克隆git仓库，可以先设置好git代理 git config --global http.proxy http://: git config --global http.proxy http://: # 选择一个合适的位置克隆项目 git clone https://github.com/PKUHPC/Crane.git cd Crane mkdir build cd build/ # 首次编译需要下载第三方库，耗时较长 cmake -G Ninja -DCMAKE_C_COMPILER=/opt/rh/devtoolset-11/root/usr/bin/gcc -DCMAKE_CXX_COMPILER=/opt/rh/devtoolset-11/root/usr/bin/g++ -DBOOST_INCLUDE_DIR=/usr/lib64/ -DBOOST_LIBRARY_DIR=/usr/include .. ninja install 6.Pam模块(待完善) 首次编译完成后需要将pam模块动态链接库放入系统指定位置 cp Crane/build/src/Misc/Pam/pam_Crane.so /usr/lib64/security/ 同时计算节点“/etc/security/access.conf”文件禁止非root用户登录 Required pam_access.so 7.运行项目 首先根据自身的集群情况在配置文件当中进行相应配置，配置文件样例保存在/etc/crane/config.yaml.example cp /etc/crane/config.yaml.example /etc/crane/config.yaml vim /etc/crane/config.yaml 启动服务 systemctl start cranectld # 控制节点守护程序服务 systemctl start cranectld # 计算节点守护程序服务 *其他节点环境部署 其他节点部署项目，无需编译项目，仅需复制相应的执行文件和配置文件即可 pscp /usr/local/bin/cranectld all:/usr/local/bin/ pscp /usr/local/bin/craned all:/usr/local/bin/ pscp /etc/systemd/system/cranectld.service all:/etc/systemd/system/ pscp /etc/systemd/system/craned.service all:/etc/systemd/system/ pscp /etc/crane/config.yaml all:/etc/crane/ "},"config/Crane-FrontEnd Configuration.html":{"url":"config/Crane-FrontEnd Configuration.html","title":"3.2 Crane 前端环境配置","keywords":"","body":"Crane-FrontEnd 项目环境配置 1.安装go语言 cd download/ wget https://golang.google.cn/dl/go1.17.3.linux-amd64.tar.gz tar -C /usr/local -xzf go1.17.3.linux-amd64.tar.gz # 在 /etc/profile中设置环境变量 export GOROOT=/usr/local/go export GOPATH=/usr/local/gopath export PATH=$PATH:/$GOROOT/bin:$GOPATH/bin source /etc/profile # 加载环境变量 go version #设置代理 go env -w GOPROXY=https://goproxy.cn,direct #开启go mod管理 go env -w GO111MODULE=on # 安装插件 go install google.golang.org/protobuf/cmd/protoc-gen-go@latest go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest 2.安装protoc wget https://github.com/protocolbuffers/protobuf/releases/download/v3.19.4/protobuf-all-3.19.4.tar.gz tar -xzf protobuf-all-3.19.4.tar.gz cd protobuf-3.19.4 ./configure -prefix=/usr/local/ make && make install protoc --version # libprotoc 3.11.2 3.拉取项目 git clone https://github.com/RileyWen/Crane-FrontEnd.git # 克隆项目代码 mkdir Crane-FrontEnd/out mkdir Crane-FrontEnd/generated/protos 4.编译项目 # 在Crane-FrontEnd/protos目录下 protoc --go_out=../generated --go-grpc_out=../generated ./* # 在Crane-FrontEnd/out目录下编译所有命令 go build ../cmd/cacctmgr/cacctmgr.go go build ../cmd/cbatch/cbatch.go go build ../cmd/ccancel/ccancel.go go build ../cmd/ccontrol/ccontrol.go go build ../cmd/cinfo/cinfo.go go build ../cmd/cqueue/cqueue.go 5.部署前端命令 cp ./* /usr/local/bin/ "},"command/cinfo.html":{"url":"command/cinfo.html","title":"4.1 cinfo 查看节点与分区状态","keywords":"","body":"cinfo 查看节点与分区状态 cinfo可查询各分区节点的队列资源信息。 查看分区节点状态： cinfo cinfo运行结果展示 主要输出项 PARTITION：分区名 AVAIL： 分区状态 idel： 空闲 mix： 节点部分核心可以使用 alloc： 节点已被占用 down： 节点不可用 NODES：节点数 NODELIST： 节点列表 主要参数 --help: 显示帮助 "},"command/cbatch.html":{"url":"command/cbatch.html","title":"4.2 cbatch 提交批处理作业","keywords":"","body":"cbatch 提交批处理作业 cbatch主要是将用户描述整个计算过程的脚本传递给作业调度系统，并为作业分配作业号，等待作业调度系统为其分配资源并执行。 首先介绍一个简单的单节点作业的例子: 下列作业将申请一个节点，一个CPU核心，并在计算节点上运行hostname并退出 #!/bin/bash #CBATCH --task-per-node 1 #CBATCH --node 1 #CBATCH -c 1 #CBATCH --mem 20M #CBATCH --time 0:3:1 #CBATCH -o job.out #CBATCH -p CPU #CBATCH -J Test_Job hostname 假设上面作业脚本的文件名为crane_submit.sh，通过cbatch命令提交： cbatch crane_submit.sh cbatch运行结果展示 主要参数： --node： 申请的节点数量 --task-per-node： 每个节点上运行的任务数量 -c: 每个节点申请的CPU核心数 --mem： 每个节点申请的内存大小 --time： 作业的最长运行时间 -o： 指定作业的标准输出重定向 -p： 作业使用的分区/队列 -J： 作业名 常用环境变量 变量名 说明 CRANE_JOB_NODELIST 作业分配的节点列表 %j 作业号 下面介绍提交一个跨节点多核心的例子： 下列作业将在三个节点上运行，每个节点使用4个CPU核心。 #!/bin/bash #CBATCH -o crane_test%j.out #CBATCH -p CPU #CBATCH -J \"crane_test\" #CBATCH --node 3 ##CBATCH --task-per-node 4 #CBATCH -c 4 #CBATCH --time 50:00:00 # 生成作业分配的节点的machinefile echo \"$CRANE_JOB_NODELIST\" | tr \";\" \"\\n\" > crane.hosts #加载MPI运行环境 module load mpich/4.0 #执行跨节点并行任务 mpirun -n 13 -machinefile crane.hosts helloWorld > log "},"command/cqueue.html":{"url":"command/cqueue.html","title":"4.3 cqueue 查看作业队列","keywords":"","body":"cqueue 查看作业队列 cqueue可以查看队列中的作业信息。 查看集群中所有队列的作业信息。 cqueue cqueue运行结果展示 主要输出项 TaskId：作业名 Type： 作业类型 Status：作业状态 NodeIndex： 作业运行的节点名 主要参数 --help: 显示帮助 "},"command/ccancel.html":{"url":"command/ccancel.html","title":"4.4 ccancel 取消运行或提交的作业","keywords":"","body":"ccancel 取消作业 ccancel可以终止正在运行或者在排队中的作业。 取消作业号为280的作业： ccancel 280 ccancel运行结果展示 取消作业之后，如果被分配节点上没有用户的其他作业，作业调度系统会终止用户在所分配节点的所有进程，并取消用户在所分配节点上的ssh权限。 "},"command/ccontrol.html":{"url":"command/ccontrol.html","title":"4.5 ccontrol 查看分区和节点状态","keywords":"","body":"ccontrol 查看分区和节点状态 ccontrol可以查看分区和节点的状态。 1. 查看分区状态 ccontrol show partition ccontrol show partition运行结果展示 主要输出项 PartitionName：分区名 State：分区状态 TotalNodes：分区节点数目 AliveNodes：分区中可运行的节点数目 TotalCpus：分区中所有节点总CPU数目 AvailCpus：分区中所有可以使用的CPU数目 AllocCpus：分区中已经被分配的CPU数目 FreeCpus：分区中空闲的CPU数目 TotalMem：分区节点的总内存 AvailMem：分区中当前可以使用的内存大小 AllocMem：分区中已分配的内存大小 FreeMem：分区中空闲的内存大小 HostList：分区中所有节点的节点名列表 2. 查看节点状态 ccontrol show node ccontrol show node运行结果展示 主要输出项 NodeName：节点名 State：节点状态 IDLE： 节点空闲，可使用 DOWN： 节点宕机，不可用 CPUs：节点CPU数目 AllocCpus：节点已分配的CPU数目 FreeCpus：节点空闲的CPU数目 RealMemory：节点的实际内存大小 AllocMem：节点已经分配的内存大小 FreeMem：节点空闲的内存大小 Patition：节点所属分区 RunningTask：节点上正在运行的作业数量 "},"command/cacctmgr.html":{"url":"command/cacctmgr.html","title":"4.6 cacctmgr 管理用户/账户信息","keywords":"","body":"cacctmgr 管理用户/账户信息 cacctmgr 可以管理账户/用户信息，包括添加账户/用户、删除账户/用户、查找账户/用户。 Crane作业调度系统中有三个用户角色： 系统管理员（Admin）：可以增删查改任何账户和用户信息 账户管理员（Operator）：可以修改部分该账户信息及账户下用户信息 普通用户(None)： 仅可以查看部分信息，不可以修改所有用户和账户信息 1. 添加账户 cacctmgr add account -name=China -describe=motherland -partition=[CPU,GPU,UU] -Qos=normal 主要参数 Qos： 服务质量 describe： 账户描述信息 name： 账户名 parent： 父账户 partition： 可使用的分区名 2. 添加用户 系统管理员可以添加任意账户的用户， 账号管理员可以添加同一账号下的新用户。 cacctmgr add user –name=xiaoming -account=China -level=admin 主要参数 account： 账户名 level： 用户权限 Admin： 系统管理员 Operator： 账户管理员 None： 普通用户 name： 用户名 partition： 可使用的分区名 3. 删除用户 系统管理员可以删除任意账户下的用户， 账户管理员可以删除同一账户下的新用户。 cacctmgr delete user xiaohong 4. 删除账户 仅系统管理员可以删除账户 cacctmgr delete account TEST 5. 查找用户 所有用户均可以使用查询功能 cacctmgr find user xiaohong 6. 查找账户 cacctmgr cacctmgr find account TEST 7. 修改账户 系统管理员可以修改任意信息， 账户管理员可以修改本身账户的信息，但不能更改账户的父账户。 cacctmgr add account -name=China -describe=motherland 主要参数 Qos： 服务质量 describe： 账户描述信息 name： 账户名 parent： 父账户 partition： 可使用的分区名 type： 对账户运行的分区操作 add： 默认是添加操作 delete: 删除 overwrite： 覆盖 8. 修改用户 系统管理员可以修改任意信息， 账户管理员可以修改同账户下用户的信息，但不能更改用户的账户。 cacctmgr set user -name=xiaoming -L=admin 主要参数 account： 账户名 level： 用户权限 Admin： 系统管理员 Operator： 账户管理员 None： 普通用户 name： 用户名 partition： 可使用的分区名 9. 显示账户树 系统管理员会显示数据库所有根账户的账户树， 账户管理员和用户会显示本身账户的账户树。 cacctmgr show accounts 10. 显示用户 系统管理员会显示所有用户， 账户管理员和用户会显示同一账户下的所有用户。 cacctmgr show users "}}